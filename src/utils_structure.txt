This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-27T14:18:48.851Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
auth.ts
axios_client.ts
httpMethods.ts
interfaces.ts
util.ts

================================================================
Repository Files
================================================================

================
File: auth.ts
================
import jwtDecode, { JwtPayload } from "jwt-decode";
import { ILoggedInUser } from "./interfaces";

/**
 * @author Ankur Mundra on June, 2023
 */

export function setAuthToken(token: string): ILoggedInUser {
  const decodedToken = jwtDecode<JwtPayload>(token);

  if (!decodedToken) {
    throw new Error("Invalid token");
  }

  if (!decodedToken.exp) {
    throw new Error("Expiration time not found in token");
  }
  const expirationDate = new Date(decodedToken.exp * 1000);
  localStorage.setItem("token", token);
  localStorage.setItem("expiration", expirationDate.toISOString());

  return decodedToken as ILoggedInUser;
}

export function getTokenDuration(): number {
  const storedExpirationDate = localStorage.getItem("expiration");

  if (!storedExpirationDate) {
    throw new Error("Expiration date not found in local storage");
  }

  const expirationDate = new Date(storedExpirationDate);
  const now = new Date();
  return expirationDate.getTime() - now.getTime();
}

function isTokenExpired(): boolean {
  const tokenDuration = getTokenDuration();
  return tokenDuration < 0;
}

export function getAuthToken(): string | null {
  const token = localStorage.getItem("token");
  if (!token) return null;
  return isTokenExpired() ? "EXPIRED" : token;
}

================
File: axios_client.ts
================
import axios from "axios";
import { getAuthToken } from "./auth";

/**
 * @author Ankur Mundra on June, 2023
 */

const axiosClient = axios.create({
  baseURL: "http://localhost:3002/api/v1",
  timeout: 1000,
  headers: {
    "Content-Type": "application/json",
    Accept: "application/json",
  },
});

axiosClient.interceptors.request.use((config) => {
  const token = getAuthToken();
  if (token && token !== "EXPIRED") {
    config.headers["Authorization"] = `Bearer ${token}`;
    return config;
  }
  return Promise.reject("Authentication token not found! Please login again.");
});
export default axiosClient;

================
File: httpMethods.ts
================
/**
 * @author Ankur Mundra on April, 2023
 */

export enum HttpMethod {
  GET = "GET",
  POST = "POST",
  PUT = "PUT",
  PATCH = "PATCH",
  DELETE = "DELETE",
}

================
File: interfaces.ts
================
/**
 * @author Ankur Mundra on June, 2023
 */

export interface IEditor {
  mode: "create" | "update";
}

export interface IRole {
  id?: number;
  name: string;
  parent_id: number;
}

export interface IInstitution {
  id?: number;
  name: string;
}

export interface IInstructor {
  id?: number;
  name: string;
}

export interface ITA {
  id?: number;
  name: string;
}

export interface IUserResponse {
  id: number;
  name: string;
  email: string;
  full_name: string;
  email_on_review: boolean;
  email_on_submission: boolean;
  email_on_review_of_review: boolean;
  role: { id: number; name: string };
  parent: { id: number | null; name: string | null };
  institution: { id: number | null; name: string | null };
}


export interface IParticipantResponse {
  id: number;
  name: string;
  email: string;
  full_name: string;
  email_on_review: boolean;
  email_on_submission: boolean;
  email_on_review_of_review: boolean;
  role: { id: number; name: string };
  parent: { id: number | null; name: string | null };
  institution: { id: number | null; name: string | null };
}

export interface IUserRequest {
  name: string;
  email: string;
  full_name: string;
  role_id: number;
  parent_id?: number | null;
  institution_id: number;
  email_on_review?: boolean;
  email_on_submission?: boolean;
  email_on_review_of_review?: boolean;
}

export interface IParticipantRequest {
  name: string;
  email: string;
  full_name: string;
  role_id: number;
  parent_id?: number | null;
  institution_id: number;
  email_on_review?: boolean;
  email_on_submission?: boolean;
  email_on_review_of_review?: boolean;
}
export interface IAssignmentRequest {
  name: string,
  directory_path: string,
  spec_location:string,
  private:boolean,
  show_template_review: boolean,
  require_quiz:boolean,
  has_badge:boolean,
  staggered_deadline:boolean,
  is_calibrated:boolean,
}

export interface ITAResponse {
  id: number;
  name: string;
  email: string;
  full_name: string;
  email_on_review: boolean;
  email_on_submission: boolean;
  email_on_review_of_review: boolean;
  role: { id: number; name: string };
  parent: { id: number | null; name: string | null };
  institution: { id: number | null; name: string | null };
}

export interface ITARequest {
  name: string;
}

export interface ILoggedInUser {
  id: number;
  name: string;
  full_name: string;
  role: string;
  institution_id: number;
}

export interface ICourseResponse{
  id: number;
  name: string;
  directory_path: string;
  info: string;
  private: boolean;
  created_at: Date;
  updated_at: Date;
  institution_id: number;
  instructor_id: number;
  institution: { id: number | null; name: string | null };
  instructor: { id: number | null; name: string | null };
}

export interface ICourseRequest{
  name: string;
  directory_path: string;
  info: string;
  private: boolean;
  institution_id: number;
  instructor_id: number;
}

export interface IInstitutionResponse {
  id: number;
  name: string;
}

export enum ROLE {
  SUPER_ADMIN = "Super Administrator",
  ADMIN = "Administrator",
  INSTRUCTOR = "Instructor",
  TA = "Teaching Assistant",
  STUDENT = "Student",
}

export interface IAssignmentResponse {
  id: number;
  name: string;
  course_id: number;
  courseName: string;
  created_at: Date; 
  updated_at: Date; 
  directory_path: string;
  spec_location:string;
  private:boolean;
  show_template_review: boolean;
  require_quiz:boolean;
  has_badge:boolean;
  staggered_deadline:boolean;
  is_calibrated:boolean;
  
}


// Assuming that your transformation function for assignment responses might look like this
export const transformAssignmentResponse = (assignmentResponse: string): IAssignmentResponse => {
  const assignment: IAssignmentResponse = JSON.parse(assignmentResponse);
  // Transform response as needed
  return assignment;
};

================
File: util.ts
================
/**
 * @author Ankur Mundra on June, 2023
 */
import { ROLE } from "./interfaces";

interface Privileges {
  [key: string]: number;
}

interface PrivilegeID {
  [key: number]: string;
}

const privilegeID: PrivilegeID = {
  1: "Student",
  2: "Teaching Assistant",
  3: "Instructor",
  4: "Administrator",
  5: "Super Administrator",
}

export function getPrivilegeFromID(roleId: number): string {
  return privilegeID[roleId];
}

const privileges: Privileges = {
  Student: 1,
  "Teaching Assistant": 2,
  Instructor: 3,
  Administrator: 4,
  "Super Administrator": 5,
};

export function hasAllPrivilegesOf(role: string, targetRole: ROLE): boolean {
  return privileges[role] >= privileges[targetRole];
}
